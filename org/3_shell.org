#+TITLE:Working with commands & the filesystem
#+AUTHOR: [yourname]
#+SUBTITLE:OS Practice CSC 420 Spring 2024
#+STARTUP:overview hideblocks indent
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args:bash :exports both :results output
* README

- You can code along with the file [[http://tinyurl.com/3-codealong-org][tinyurl.com/3-codealong.org]]

  You can save it to an Org-mode file ~3-shell.org~

- Upload the finished codealong file [[https://lyon.instructure.com/courses/2255/assignments/25142][to Canvas]]

- You can get the Emacs configuration file for Pi OS from
  ~tinyurl.com/EmacsLyonPi~

- The solutions and results herein were all obtained on a Lenovo
  laptop running Linux Mint 21.3 with 4 Intel Core i3-6006U CPUs.

- This lab is based on chapter 5 (pp. 39-48) of Shotts (2019).

- You can get the completed file from ~tinyurl.com/3-shell-org~

* Command summary

| COMMAND | MEANING                       | EXAMPLE             |
|---------+-------------------------------+---------------------|
| type    | how a cmd name is interpreted | type ls             |
| which   | which cmd is executed         | which ls            |
| help    | help for shell built-ins      | help cd             |
| man     | full manual page              | man ls              |
| apropos | searches matching manuals     | apropos --exact apt |
| info    | info entry (hyperlinked)      | info ls             |
| whatis  | one-line manual extract       | whatis ls           |
| alias   | create command alias          | alias ll='ls -alF'  |

* The linux file system ("everything is a file")
Open a terminal (or a shell in Emacs) and look at the file system
#+name: file_system
#+begin_src bash
  ls -lF /
#+end_src

You'll see something like this:
#+attr_html: :width 600px:
[[../img/filesystem.png]]

| DIRECTORY      | CONTENT                                               |
|----------------+-------------------------------------------------------|
| ~/~              | Root directory where everything begins                |
| ~/bin~           | Executable binaries for the OS to boot and run        |
| ~/boot~          | Linux kernel, initial RAM disk image to boot          |
| ~/dev~           | List for kernel with all known devices                |
| ~/etc~           | System configuration files (e.g. ~/etc/passwd~)         |
| ~/home~          | Directory for user directories (e.g. ~/home/pi~)        |
| ~/lib~           | Shared library files (like Windows DLLs)              |
| ~/lost+found~    | Panic room for each formatted disk partition          |
| ~/media~         | Mount points for removable media (e.g. USB stick)     |
| ~/mnt~           | Mount points for manually mounted removable media     |
| ~/opt~           | Optional commercial software (e.g. browser)           |
| ~/proc~          | Virtual FS for the kernel (e.g. ~/proc/cpuinfo~)        |
| ~/run~           | Runtime information? Check it out                     |
| ~/root~          | ~$HOME~ directory of the ~root~ super-user                |
| ~/sbin~          | System binaries for system tasks (~sudo shutdown~)      |
| ~/tmp~           | Holding bay for temp files, emptied at reboot         |
| ~/usr~           | Programs and support files for regular users          |
| ~/usr/bin~       | Executable programs of the distro (e.g. ~cat~)          |
| ~/usr/lib~       | Shared libraries for ~/usr/bin~ programs                |
| ~/usr/local~     | Programs not included in your distro                  |
| ~/usr/sbin~      | More system administration programs                   |
| ~/usr/share~     | Shared data for  ~/usr/bin~ programs (e.g. sound files) |
| ~/usr/share/doc~ | Man pages and other package documentation             |
| ~/var~           | Databases, spool files, user mail (volatile files)    |
| ~/var/log~       | Records of system activity (e.g. ~/var/log/syslog~)     |

* Special files

- Special files in Unix and Linux systems are identified primarily by
  their file type, which is indicated by the first character in the
  file's long listing format displayed by the ls -l
  command. Additionally, their location within the filesystem,
  particularly in directories like /dev and /proc, helps identify
  their nature and purpose. Here's how you can identify various types
  of special files:
  1. Character Device Files: Identified by a 'c' at the beginning of
     the file permissions string in the output of ls -l. These files
     represent devices that handle data as a stream of bytes, like
     keyboards or serial ports.

      Example: crw-rw-rw- 1 root tty 5, 0 Mar 1 12:34 /dev/tty

   2. Block Device Files: Identified by a 'b' at the beginning of the
      file permissions string. Block device files represent devices
      that handle data in blocks, such as hard drives and disk
      partitions.
      #+begin_example
      brw-rw---- 1 root disk 8, 0 Mar 1 12:34 /dev/sda
      #+end_example

    3. Pipes: Named pipes (also known as FIFOs, for First In First
       Out) are identified by a 'p' at the beginning of the file
       permissions string. Pipes are used for inter-process
       communication.
       #+begin_example
       prw-r--r-- 1 user group 0 Mar 1 12:34 /path/to/named_pipe
       #+end_example

    4. Sockets: Used for network communication, sockets are identified
       by an 's' at the beginning of the file permissions string. They
       facilitate communication between processes, either on the same
       machine or across networks.
       #+begin_example
       srwxrwxrwx 1 user group 0 Mar 1 12:34 /tmp/socket
       #+end_example
    5. Symbolic Links: Symbolic links are identified by an 'l' at the
       beginning of the file permissions string. A symbolic link is a
       type of file that points to another file or directory.
       #+begin_example
       lrwxrwxrwx 1 user group 7 Mar 1 12:34 /path/to/symlink -> /target
       #+end_example

    6. Directories and Regular Files: While not special files, for
       completeness, directories are identified by a 'd', and regular
       files have no specific identifier at the beginning of their
       permissions string.
       #+begin_example
        drwxr-xr-x 2 user group 4096 Mar 1 12:34 /path/to/directory
       #+end_example
       #+begin_example
       -rw-r--r-- 1 user group 123 Mar 1 12:34 /path/to/file
       #+end_example

Special files are managed by the operating system and provide an
interface to hardware devices, inter-process communication mechanisms,
and system information beyond traditional byte-oriented files.

* What is a command?

There are four types of commands:
- built-ins
- binaries/executables
- shell functions
- aliases.

- An *executable* program e.g. in ~/usr/bin~ - could be compiled from
  source (e.g. from C), or scripted (e.g. from bash), like =make(1).=

- A *builtin*, a command built into the shell itself, like ~cd~:
  #+begin_src bash
    type cd
  #+end_src

  #+RESULTS:
  : cd is a shell builtin

- A *shell function*, scripts incorporated into the environment like
  ~~/.bashrc~, which is a configuration file, or like this little =git=
  script that I use for version control:
  #+begin_example bash
  #!/bin/bash

# Define an array with the directory names
directories=("admin" "cpp" "db24" "ds205" "org" "os24" "research")

# Save the current directory
start_dir=$(pwd)

# Loop through the directories and check `git status`
for dir in "${directories[@]}"; do
    if [ -d "$dir" ]; then
        # echo "Entering $dir..."
        cd "$dir"
        # Check if there are changes
        if [ -n "$(git status --porcelain)" ]; then
            echo "$dir needs update"
        else
            echo "Up to date" > /dev/null
        fi
        # Return to the starting directory
        cd "$start_dir"
    else
        echo "Directory $dir does not exist."
    fi
done

#echo "Done."

  #+end_example

- An =alias=, commands that we can define from other commands, e.g. as
  defined in ~~/.bashrc~, which colorizes the output:
  #+begin_example bash
    alias ls='ls --color=auto'
  #+end_example

* Identify commands with =type= and =which=

- =type= is a built-in (check that?), which displays the kind of command
  executed by the shell. Try it on ~ls~ and ~type~, and then try ~type -a
  grep~:
  #+begin_src bash
    type ls
    type type
    type -a grep # all locations of the command
  #+end_src

  #+RESULTS:
  : ls is /usr/bin/ls
  : type is a shell builtin
  : grep is /usr/bin/grep
  : grep is /bin/grep

- If you try ~type -a grep~ in a real terminal (not in Emacs), you get
  an additional answer, ~grep is aliased to `grep --color=auto`~.

- To find out =which= of perhaps many different commands with the same
  name is executed, use ~which~.
  #+begin_src bash
    which ls
  #+end_src

- ~which~ only works for executable programs (not aliases, not
  builtins). Try it on a builtin command:
  #+begin_src bash :results output
    which cd  # it's a built-in
    type cd
    which gcc # it's an executable
    type -a gcc 
  #+end_src

  #+RESULTS:
  : cd is a shell builtin
  : /usr/bin/gcc
  : gcc is /usr/bin/gcc
  : gcc is /bin/gcc

* From a time before Google: getting help with =help=

- ~bash~ has a built-in help facility for each of the shell
  builtins. Try it for ~cd~:
  #+begin_src bash
    help cd
  #+end_src

  #+RESULTS:
  #+begin_example
  cd: cd [-L|[-P [-e]] [-@]] [dir]
      Change the shell working directory.

      Change the current directory to DIR.  The default DIR is the value of the
      HOME shell variable.

      The variable CDPATH defines the search path for the directory containing
      DIR.  Alternative directory names in CDPATH are separated by a colon (:).
      A null directory name is the same as the current directory.  If DIR begins
      with a slash (/), then CDPATH is not used.

      If the directory is not found, and the shell option `cdable_vars' is set,
      the word is assumed to be  a variable name.  If that variable has a value,
      its value is used for DIR.

      Options:
        -L	force symbolic links to be followed: resolve symbolic
                  links in DIR after processing instances of `..'
        -P	use the physical directory structure without following
                  symbolic links: resolve symbolic links in DIR before
                  processing instances of `..'
        -e	if the -P option is supplied, and the current working
                  directory cannot be determined successfully, exit with
                  a non-zero status
        -@	on systems that support it, present a file with extended
                  attributes as a directory containing the file attributes

      The default is to follow symbolic links, as if `-L' were specified.
      `..' is processed by removing the immediately previous pathname component
      back to a slash or the beginning of DIR.

      Exit Status:
      Returns 0 if the directory is changed, and if $PWD is set successfully when
      -P is used; non-zero otherwise.
  #+end_example

- In all documentation, ~[ ]~ indicates optional items, like here:
  #+begin_example bash
  cd [-L|[-P [-e]] [-@]] [dir]
  #+end_example

- Meaning: ~cd~ can be followed by either ~-L~ or ~-P~, and if ~-P~ is
  specified, then the ~-e~ option can be included followed by ~dir~ with
  the default ~$HOME~.

- Show that ~cd~ can be run without option or argument, and that this
  use of ~cd~ defaults to going ~$HOME~.
  #+begin_src bash
    pwd
    cd
    pwd
  #+end_src

  #+RESULTS:
  : /home/marcus/GitHub/os24/org
  : /home/marcus

- Many executable programs support the ~--help~ option that gives an
  overview of syntax and options: try this option for ~type~.
  #+begin_src bash
    type --help
  #+end_src

  #+RESULTS:
  #+begin_example
  type: type [-afptP] name [name ...]
      Display information about command type.

      For each NAME, indicate how it would be interpreted if used as a
      command name.

      Options:
        -a	display all locations containing an executable named NAME;
                  includes aliases, builtins, and functions, if and only if
                  the `-p' option is not also used
        -f	suppress shell function lookup
        -P	force a PATH search for each NAME, even if it is an alias,
                  builtin, or function, and returns the name of the disk file
                  that would be executed
        -p	returns either the name of the disk file that would be executed,
                  or nothing if `type -t NAME' would not return `file'
        -t	output a single word which is one of `alias', `keyword',
                  `function', `builtin', `file' or `', if NAME is an alias,
                  shell reserved word, shell function, shell builtin, disk file,
                  or not found, respectively

      Arguments:
        NAME	Command name to be interpreted.

      Exit Status:
      Returns success if all of the NAMEs are found; fails if any are not found.
  #+end_example

  #+begin_src bash
    gcc --help
  #+end_src

  #+RESULTS:
  #+begin_example
  Usage: gcc [options] file...
  Options:
    -pass-exit-codes         Exit with highest error code from a phase.
    --help                   Display this information.
    --target-help            Display target specific command line options.
    --help={common|optimizers|params|target|warnings|[^]{joined|separate|undocumented}}[,...].
                             Display specific types of command line options.
    (Use '-v --help' to display command line options of sub-processes).
    --version                Display compiler version information.
    -dumpspecs               Display all of the built in spec strings.
    -dumpversion             Display the version of the compiler.
    -dumpmachine             Display the compiler's target processor.
    -print-search-dirs       Display the directories in the compiler's search path.
    -print-libgcc-file-name  Display the name of the compiler's companion library.
    -print-file-name=<lib>   Display the full path to library <lib>.
    -print-prog-name=<prog>  Display the full path to compiler component <prog>.
    -print-multiarch         Display the target's normalized GNU triplet, used as
                             a component in the library path.
    -print-multi-directory   Display the root directory for versions of libgcc.
    -print-multi-lib         Display the mapping between command line options and
                             multiple library search directories.
    -print-multi-os-directory Display the relative path to OS libraries.
    -print-sysroot           Display the target libraries directory.
    -print-sysroot-headers-suffix Display the sysroot suffix used to find headers.
    -Wa,<options>            Pass comma-separated <options> on to the assembler.
    -Wp,<options>            Pass comma-separated <options> on to the preprocessor.
    -Wl,<options>            Pass comma-separated <options> on to the linker.
    -Xassembler <arg>        Pass <arg> on to the assembler.
    -Xpreprocessor <arg>     Pass <arg> on to the preprocessor.
    -Xlinker <arg>           Pass <arg> on to the linker.
    -save-temps              Do not delete intermediate files.
    -save-temps=<arg>        Do not delete intermediate files.
    -no-canonical-prefixes   Do not canonicalize paths when building relative
                             prefixes to other gcc components.
    -pipe                    Use pipes rather than intermediate files.
    -time                    Time the execution of each subprocess.
    -specs=<file>            Override built-in specs with the contents of <file>.
    -std=<standard>          Assume that the input sources are for <standard>.
    --sysroot=<directory>    Use <directory> as the root directory for headers
                             and libraries.
    -B <directory>           Add <directory> to the compiler's search paths.
    -v                       Display the programs invoked by the compiler.
    -###                     Like -v but options quoted and commands not executed.
    -E                       Preprocess only; do not compile, assemble or link.
    -S                       Compile only; do not assemble or link.
    -c                       Compile and assemble, but do not link.
    -o <file>                Place the output into <file>.
    -pie                     Create a dynamically linked position independent
                             executable.
    -shared                  Create a shared library.
    -x <language>            Specify the language of the following input files.
                             Permissible languages include: c c++ assembler none
                             'none' means revert to the default behavior of
                             guessing the language based on the file's extension.

  Options starting with -g, -f, -m, -O, -W, or --param are automatically
   passed on to the various sub-processes invoked by gcc.  In order to pass
   other options on to these processes the -W<letter> options must be used.

  For bug reporting instructions, please see:
  <file:///usr/share/doc/gcc-11/README.Bugs>.
  #+end_example
  
- Try the option ~--help~ for ~help~.
  #+begin_src bash
    help --help
  #+end_src

* Getting help from the =man= page & your =fortune=

- Executable programs that can be run on the command line have a
  manual or man page. The ~man~ program is used to view them. Try it on
  ~ls~ first using a code block, and then display it in a separate
  buffer with ~M-x man RET ls~.
  #+begin_src bash
    man pwd
  #+end_src

  #+RESULTS:
  #+begin_example
  PWD(1)                           User Commands                          PWD(1)

  NAME
         pwd - print name of current/working directory

  SYNOPSIS
         pwd [OPTION]...

  DESCRIPTION
         Print the full filename of the current working directory.

         -L, --logical
                use PWD from environment, even if it contains symlinks

         -P, --physical
                avoid all symlinks

         --help display this help and exit

         --version
                output version information and exit

         If no option is specified, -P is assumed.

         NOTE:  your shell may have its own version of pwd, which usually super‐
         sedes the version described here.  Please refer to your  shell's  docu‐
         mentation for details about the options it supports.

  AUTHOR
         Written by Jim Meyering.

  REPORTING BUGS
         GNU coreutils online help: <https://www.gnu.org/software/coreutils/>
         Report any translation bugs to <https://translationproject.org/team/>

  COPYRIGHT
         Copyright  ©  2020  Free Software Foundation, Inc.  License GPLv3+: GNU
         GPL version 3 or later <https://gnu.org/licenses/gpl.html>.
         This is free software: you are free  to  change  and  redistribute  it.
         There is NO WARRANTY, to the extent permitted by law.

  SEE ALSO
         getcwd(3)

         Full documentation <https://www.gnu.org/software/coreutils/pwd>
         or available locally via: info '(coreutils) pwd invocation'

  GNU coreutils 8.32               January 2024                           PWD(1)
  #+end_example

- Try ~man~ on a shell builtin, e.g. ~help~:
  #+begin_src bash :results silent
    man help
  #+end_src

- The format of a manual page is
  1) title (page name including the command section)
  2) synopsis of the syntax
  3) description of the purpose
  4) listing and description of each of the options

- Man pages are not vignettes like you might know them from R or from
  the Python standard library, with examples. They are not tutorials
  but only reference pages.

- ~man~ uses ~less~ to display its information.

- The Unix manual is broken into sections:
  1) run these in a terminal or inside Emacs. When you address a
     section, you can prefix the number, e.g. ~man 3 printf~.
  2) find out ~which~ command is executed when you run it.

  | Section | Contents                         | Example      |
  |---------+----------------------------------+--------------|
  |       1 | User commands (~/usr/~)            | bash(1)      |
  |       2 | Interface to kernel system calls | write(2)     |
  |       3 | Interface to C library           | printf(3)    |
  |       4 | Special device files (~/dev~)      | /dev/null    |
  |       5 | File formats                     | /etc/passwd  |
  |       6 | Games                            | fortune      |
  |       7 | Miscellaneous                    | inode(7)     |
  |       8 | System admin commands/daemons    | cron(8)      |

- Where are these commands located?
  #+begin_src bash
    which bash
    which write # see later in `redirection`
    type -a printf # see example below
    ls -l /dev/null # notice the file type `c`
    ls -l /etc/passwd # check out `man 5 passwd`
    which fortune
    ls -l /usr/share/man/man7/inode*
    which cron # essential for scheduling backups, updates etc.
  #+end_src

- Some functions have the same name but are different
  programs. E.g. there is a user-command ~printf(1)~ to print stuff
  from the terminal:
  #+begin_src bash
    printf "Hello, I'm printf(1)\n"
  #+end_src

  #+RESULTS:
  : Hello, I'm printf(1)

  And there's ~printf(3)~ which refers to the standard library
  function in ~stdio.h~ that you use in C programs:
  #+begin_src C :main yes :includes <stdio.h> :results output :exports both :noweb yes
    printf("Hello, I'm printf(3)\n");
  #+end_src

  #+RESULTS:
  : Hello, I'm printf(3)

- Let's play the ~fortune~ game:
  #+begin_src bash
    fortune
  #+end_src

  #+RESULTS:
  : You'd like to do it instantaneously, but that's too slow.

- Hey, the command and its man page are not found. Open a fully
  functional terminal and run these commands:
  #+begin_example bash
  $ sudo apt install fortune -y
  $ fortune
  $ man fortune
  $ which fortune
  #+end_example

- Can you generate a "potentially offensive" fortune cookie?
  #+begin_src bash
    fortune -o > offensive_fortune
    ls -l offensive_fortune
  #+end_src

  #+RESULTS:
  : -rw-rw-r-- 1 marcus marcus 0 Mar  7 10:18 offensive_fortune

- The shell, ~bash(1)~ has one of the longest man pages (80). It's
  essentially a booklet. ~GCC(1)~ the C compiler beats this, it's a
  book. Don't print these out.

* Display appropriate commands with =apropos=

- =apropos= is a search function that exists in many programs -
  e.g. Emacs has such a help (try ~C-h a man~), and R does, too: in a
  terminal outside of Emacs, enter R, and on the console, enter:
  #+begin_example R
  R> ??Nile
  R> ?datasets::Nile
  #+end_example

- For a shell example, try ~apropos~ on ~fortune~, ~inode~ and ~cron~:
  #+begin_src bash
    apropos fortune
    apropos inode
    apropos cron
  #+end_src

- The ~man~ function with the ~-k~ flag performs the same job as ~apropos~:
  #+begin_src bash
    man -k fortune
  #+end_src

  #+RESULTS:
  : fortune (6)          - print a random, hopefully interesting, adage

* =whatis= in a command?

- ~whatis~ displays the name and a one-line description of a man page:
  #+begin_src bash
    whatis ls whatis printf whatis regex whatis fortune
  #+end_src

  #+RESULTS:
  : ls (1)               - list directory contents
  : whatis (1)           - display one-line manual page descriptions
  : printf (3)           - formatted output conversion
  : printf (1)           - format and print data
  : regex (3)            - POSIX regex functions
  : regex (7)            - POSIX.2 regular expressions
  : fortune (6)          - print a random, hopefully interesting, adage

* Display a commands =info= entry

- Info is a GNU project. You can use it as a standalone manual or use
  it for example inside Emacs: try ~C-h i~ and you're in it.

- Info files are created from ~.texi~ TeXinfo files using the TeX
  typesetting system created by Donald Knuth (who also invented
  literate programming), generated with ~texinfo~.

- Info pages are hyperlinked - this is in fact where Tim Berners-Lee
  (and Steve Jobs) very likely got the idea from. The creator of
  Emacs, Richard Stallman created the info system in the early 1980s.

- The ~info~ program reads info files, which are tree structured into
  nodes. Each node contains a single topic. Much like many Emacs
  modes, ~info~ navigation works with single letter commands like
  p,n,U,?.

- Print only the first 13 lines of the ~info~ for =head=:
  #+begin_src bash
    info head | head -n 13
  #+end_src

  #+RESULTS:
  #+begin_example
  File: coreutils.info,  Node: head invocation,  Next: tail invocation,  Up: Output of parts of files

  5.1 ‘head’: Output the first part of files
  ==========================================

  ‘head’ prints the first part (10 lines by default) of each FILE; it
  reads from standard input if no files are given or when given a FILE of
  ‘-’.  Synopsis:

       head [OPTION]... [FILE]...

     If more than one FILE is specified, ‘head’ prints a one-line header
  consisting of:
  #+end_example

- Find the info for =head= inside the Emacs Info reader.

- Most of the mentioned command line help programs are part of the GNU
  coreutils suite of programs: enter ~info coreutils~ in the terminal to
  see the info, and exit with `q`.

* You must =README=

- You probably noticed the `README` headline that all my scripts start
  with: this is a Unix and developer tradition.

- Software distributions usually contain a README file that lists the
  main changes and the history of changes as well as anything that you
  need to know before starting to use the software.

- On GitHub, when you create a repo of your own, GitHub will create a
  README file for you.

* Creating your own commands with =alias=

- Check out ~~/.bashrc~ (if you have it, which you should) and search
  (~C-s~) for ~alias~.

- Use one of these aliases: open a terminal or a shell in Emacs (~M-x
  shell~) and enter ~ll~, which is aliased for ~ls -alF~ (remember what
  this means? How can you find out?)

- You can put more than one command on one line separated by ~;~
  #+begin_src bash
    echo "hello"; echo "world"
  #+end_src

- On *one line*, change to ~/usr~, list all files, and go back to ~$HOME~
  again, then make sure you're ~$HOME~.

  #+begin_src bash
    cd /usr;ls;cd ~;pwd
  #+end_src

- We want to create a new command using ~alias~ called ~test~. First, find
  out if ~test~ already exists:
  #+begin_src bash
    type test
  #+end_src

- It does! Let's try ~foo~ (see [[https://en.wikipedia.org/wiki/Foobar][foobar]]) in the format ~alias='string'~ -
  you have to do this in a fully functional shell.
  #+begin_example bash
    $ alias foo='cd /usr;ls;cd ~;pwd' # defines the new command
    $ foo # runs the command sequence
    $ alias # shows all aliases
    $ type foo # displays the character of the command
  #+end_example

- To remove the alias, use ~unalias~ on the name:
  #+begin_example
  $ unalias foo
  $ type foo
  #+end_example

- Why can we not do this in Emacs?
  #+begin_quote
  Because aliases are temporary and vanish when the session ends, and
  because the Emacs terminal is only a simulatin (~M-x term~ would work
  though but it's hard to get rid of - try it: you have to ~exit~ to
  kill it.)
  #+end_quote

* References

Shotts W (2019). The Linux Command Line (2e), NoStarch Press.

* Footnotes

[fn:1] 
