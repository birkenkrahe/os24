#+TITLE:Expansion, Quoting, and Escaping
#+AUTHOR: Marcus Birkenkrahe
#+SUBTITLE:OS Practice CSC 420 Spring 2024
#+STARTUP:overview hideblocks indent
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args:bash :exports both :results output
* README

- You can code along with the file [[http://tinyurl.com/5-expansion-org][tinyurl.com/5-expansion-org]]

  You can save it to an Org-mode file ~5_expansion.org~

- The solutions and results herein were all obtained on a Lenovo
  laptop running Linux Mint 21.3 with 4 Intel Core i3-6006U CPUs.

- This lab is based on chapter 7 (pp. 61-72) of Shotts (2019).

- You can get the completed file from ~tinyurl.com/5_redirection.org~

What we'll cover:
- Pathname expansion or 'globbing' of filenames, regular and hidden
- Tilde =~= expansion
- Arithmetic expansion with =$(( ))=
- Brace expansion with ={ }=
- Parameter expansion with =$=
- Command substitution
- Quoting with double and single quotes
- Escaping characters
  
* Pathname expansion ('globbing') with =echo=

- Expansion is the process of substitution that the shell performs
  whenever you press ~ENTER~ while you're on the shell.

- 'Globbing' is a part of many languages (e.g. the database language
  and RDBMS SQLite has a =GLOB= expansion parameter).

- =echo= is a shell-builtin (check ~type echo~) that prints its text
  argument on =stdout=. There's both a =help= for the built-in and a =man=
  page for the standalone program. 

- ~echo *~ does not print =*= but the list of files in =$PWD= instead: the
  shell expands the =*= into "match any filenames in the current
  directory", and the =echo= command never sees the =*=:
  #+begin_src bash
    echo *
  #+end_src

  #+RESULTS:
  : 1_fundamentals.org 1_fundamentals_practice.org 2_manipulate_practice.org 3_shell_codealong.org 3_shell.org 4_redirection_codealong.org 4_redirection.org 5_expansion.org 5_expansion.org~ assignments joined.txt kim lazy-dog.txt ls-error.txt ls-output.txt ls.txt notebook.org offensive_fortune output1.txt output.txt pi_install.org pi.org syllabus.org xaa xab xac xad

- Let's try a few more pathname expansions: in the case of ~D*~, there's
  nothing to find, so the string ~D*~ is printed, in =$HOME=, there is:
  #+begin_src bash
    echo D* ~/D*
  #+end_src

  #+RESULTS:
  : D* /home/marcus/Desktop /home/marcus/Documents /home/marcus/Downloads

- Expansion does not just work from an initial character:
  #+begin_src bash
    echo *s  # prints all files ending in `s`
    echo ~/*p # prints all files in PWD ending in `p`
    echo /usr/*/share # prints all files in /usr with a /share subdirectory
  #+end_src  

  #+RESULTS:
  : assignments
  : /home/marcus/Desktop /home/marcus/snap
  : /usr/local/share

- In the following argument, =[[:lower;]]= matches any single character
  that is a lowercase character from the current language /locale/. It
  is a so-called POSIX (standard) character class for regex.
  #+begin_src bash
    echo ~/.[[:lower:]]*
  #+end_src

  #+RESULTS:
  : /home/marcus/.bash_history /home/marcus/.bash_logout /home/marcus/.bashrc /home/marcus/.cache /home/marcus/.config /home/marcus/.emacs /home/marcus/.emacs~ /home/marcus/.emacs.d /home/marcus/.emacs.windows /home/marcus/.gitconfig /home/marcus/.gnome /home/marcus/.gtkrc-2.0 /home/marcus/.gtkrc-xfce /home/marcus/.hplip /home/marcus/.icons /home/marcus/.lesshst /home/marcus/.linuxmint /home/marcus/.local /home/marcus/.mozilla /home/marcus/.npm /home/marcus/.nv /home/marcus/.pat /home/marcus/.pat~ /home/marcus/.pat.fine /home/marcus/.pki /home/marcus/.profile /home/marcus/.python_history /home/marcus/.sqlite_history /home/marcus/.ssh /home/marcus/.ssr /home/marcus/.sudo_as_admin_successful /home/marcus/.swt /home/marcus/.themes /home/marcus/.var /home/marcus/.wget-hsts /home/marcus/.xsession-errors /home/marcus/.xsession-errors.old /home/marcus/.zoom

- 'Regex',or regular expressions, are a key =bash= scripting skill. The
  quickest way to learn is to go to ~regex101.com~ and get to work.

* Pathname expansion of hidden files

- Filenames that begin with a period character =.= are hidden: to see
  them e.g. with =ls= you need to use the =-a= flag.
  
- =echo= respects that behavior: ~echo *~ does not print hidden files.
  #+begin_src bash
    echo .*
  #+end_src

  #+RESULTS:
  : . .. .hidden

- But the period is not like other characters: the current and the
  parent directory (=./= and =../=) are also printed - and they're not hidden:
  #+begin_src bash
    ls -d .* | less  # list all files starting with a period
  #+end_src

  #+RESULTS:
  : .
  : ..
  : .hidden

- A well performing expansion of hidden files has to use a different
  pattern:
  #+begin_src bash
    echo .[!.]*  # files beginning with a period followed by other characters
  #+end_src

  #+RESULTS:
  : .#5_expansion.org .hidden
  
- Read ~.[!.]*~ as "starts with . but not .. followed by any other
  characters". This will not find filenames starting with multiple
  periods - this is too hard with =echo= - see however =glob(3)=.
  #+begin_src bash
    touch ..very_hidden
    ls -ad .*
    echo
    echo .[!.]*
  #+end_src

  #+RESULTS:
  : .
  : ..
  : .hidden
  : ..very_hidden
  : 
  : .hidden

* Tilde expansion

- The tilde character (=~=) has a special meaning: it expands into the
  name of the home directory of the named (or current) user:
  #+begin_src bash
    echo ~
    echo ~root
  #+end_src

  #+RESULTS:
  : /home/marcus
  : /root

* Arithmetic expansion

- The shell can also do arithmetic: we can use it as a calculator,
  both on the command line and in shell scripts:
  #+begin_src bash
    echo $((2+2))
  #+end_src

  #+RESULTS:
  : 4

- The syntax (where /expression/ consists of values and arithmetic operators):
  #+begin_example
    $((expression))
  #+end_example

- Alas, arithmetic expansion only supports integers but it can add,
  subtract, multiply, divide, modulo and exponentiate, spaces are
  insignificant, and expressions can be nested.

- Example: 5 squared by 3 
  #+begin_src bash
    echo $((5**2))
    echo $(($((5**2)) * 3))
  #+end_src

  #+RESULTS:
  : 25
  : 75

- Example: 5 divided by 2
  #+begin_src bash
    echo Five divided by two equals $((5/2))
    echo with $((5%2)) left over
  #+end_src

  #+RESULTS:
  : Five divided by two equals 2
  : with 1 left over

* Brace expansion

- With brace expansion, you can create multiple text strings from a
  pattern with braces:
  #+begin_src bash
    echo Front-{A,B,C}-Back
  #+end_src

  #+RESULTS:
  : Front-A-Back Front-B-Back Front-C-Back

- Patterns to be brace expanded may contain a leading portion
  (/preamble/) and a trailing portion (/postscript/). The brace expression
  can be a comma separated list of strings or a range of integers or
  single characters. No unquoted whitespace is allowed.

- Examples:
  #+begin_src bash
    echo Number_{1..5} # range of numbers
    echo {01..15}  # zero padding
    echo {001..15} # double zero padding
    echo {Z..A}  # invert alphabet letters
  #+end_src

  #+RESULTS:
  : Number_1 Number_2 Number_3 Number_4 Number_5
  : 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
  : 001 002 003 004 005 006 007 008 009 010 011 012 013 014 015
  : Z Y X W V U T S R Q P O N M L K J I H G F E D C B A

- Brace expansions may be nested:
  #+begin_src bash
    echo a{A{1,2},B{3,4}}b
  #+end_src

  #+RESULTS:
  : aA1b aA2b aB3b aB4b

- What is brace expansion good for? Most commonly for making lists:
  for example if you wanted to organize a large collection of images
  into years and months:
  #+begin_src bash
    if [ -d Photos ]; then
        rm -rf Photos;
    fi
    mkdir -v Photos
    cd Photos
    mkdir -v {2007..2009}-{01..12}
    #+end_src
  
  - More information about this (and other) expansion methods is in the
   =bash(1)= man page or in the [[https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html][online reference manual]] for bash.

- Python has adopted this notation for the formatted or /f-string/:
  #+begin_src python :session *Python* :python python3 :results output :exports both :noweb yes 
    greeting = "world"

    print(f"Hello, {greeting}")
  #+end_src

- Emacs tables are also using this feature to turn a table into a
  spreadsheet. The following table computes the sum of two numbers. To
  turn formula debugging on/off, use ~C-c }~

  | Number | Number | Sum |
  |--------+--------+-----|
  |    100 |    100 | 200 |
  |     10 |     20 | 200 |
  |    110 |   2000 | 400 |
  #+TBLFM: @2$3=vsum($1..$2)::@3$3=vprod($1..$2)::@4$1=vsum(@2..@3)::@4$2=vprod(@2..@3)::@4$3=vsum(@2..@3)

  Formulas are achieved with Lisp (the language Emacs is written
  in). It's very handy to have active tables in Org-mode files.
  
* Parameter expansion

- Expansion of environment parameters is useful in scripts:
  #+begin_src bash
    echo $USER
  #+end_src

  #+RESULTS:
  : marcus

- To see a list of environment variables:
  #+begin_src bash
    printenv
  #+end_src

  #+RESULTS:
  #+begin_example
  SHELL=/bin/bash
  SESSION_MANAGER=local/Marcus-Lenovo-ideapad-320-15ISK:@/tmp/.ICE-unix/1325,unix/Marcus-Lenovo-ideapad-320-15ISK:/tmp/.ICE-unix/1325
  QT_ACCESSIBILITY=1
  COLORTERM=truecolor
  XDG_CONFIG_DIRS=/etc/xdg/xdg-cinnamon:/etc/xdg
  XDG_SESSION_PATH=/org/freedesktop/DisplayManager/Session0
  GNOME_DESKTOP_SESSION_ID=this-is-deprecated
  GTK_IM_MODULE=ibus
  LANGUAGE=en_US
  SSH_AUTH_SOCK=/run/user/1000/keyring/ssh
  CINNAMON_VERSION=6.0.4
  XMODIFIERS=@im=ibus
  DESKTOP_SESSION=cinnamon
  GTK_MODULES=gail:atk-bridge
  XDG_SEAT=seat0
  PWD=/home/marcus/GitHub/os24/org
  XDG_SESSION_DESKTOP=cinnamon
  LOGNAME=marcus
  QT_QPA_PLATFORMTHEME=qt5ct
  XDG_SESSION_TYPE=x11
  GPG_AGENT_INFO=/run/user/1000/gnupg/S.gpg-agent:0:1
  _=/usr/bin/printenv
  XAUTHORITY=/home/marcus/.Xauthority
  XDG_GREETER_DATA_DIR=/var/lib/lightdm-data/marcus
  GDM_LANG=en_US
  HOME=/home/marcus
  LANG=en_US.UTF-8
  LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:
  XDG_CURRENT_DESKTOP=X-Cinnamon
  VTE_VERSION=6800
  XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0
  GNOME_TERMINAL_SCREEN=/org/gnome/Terminal/screen/20feac50_9928_4407_b9db_cde01cb59928
  CLUTTER_IM_MODULE=ibus
  LESSCLOSE=/usr/bin/lesspipe %s %s
  XDG_SESSION_CLASS=user
  TERM=dumb
  LESSOPEN=| /usr/bin/lesspipe %s
  USER=marcus
  GNOME_TERMINAL_SERVICE=:1.110
  DISPLAY=:0
  SHLVL=0
  QT_IM_MODULE=ibus
  XDG_VTNR=7
  XDG_SESSION_ID=c1
  XDG_RUNTIME_DIR=/run/user/1000
  GTK3_MODULES=xapp-gtk3-module
  XDG_DATA_DIRS=/usr/share/cinnamon:/usr/share/gnome:/home/marcus/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share:/usr/local/share:/usr/share:/var/lib/snapd/desktop
  PATH=/home/marcus/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
  GDMSESSION=cinnamon
  DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus
  #+end_example

- Mistyping a pattern will result in an empty string:
  #+begin_src bash
    echo $USRE
  #+end_src

  #+RESULTS:
  : 

* Command substitution

- You can also use the output of a command as a substitution:
  #+begin_src bash
    echo $(ls)  # list command printed (on one line)
  #+end_src

  #+RESULTS:
  : 1_fundamentals.org 1_fundamentals_practice.org 2_manipulate_practice.org 3_shell_codealong.org 3_shell.org 4_redirection_codealong.org 4_redirection.org 5_expansion.org 5_expansion.org~ assignments joined.txt kim lazy-dog.txt ls-error.txt ls-output.txt ls.txt notebook.org offensive_fortune output1.txt output.txt Photos pi_install.org pi.org syllabus.org xaa xab xac xad

- You can use this e.g. to get the listing of a command without
  knowing its full pathname:
  #+begin_src bash
    ls -l $(which echo) # list the echo program
  #+end_src

  #+RESULTS:
  : -rwxr-xr-x 1 root root 35128 Jan  8 08:56 /usr/bin/echo

- You can build pipelines, too: how many files are in =$PWD= - use =ls= and =wc=
  #+begin_src bash
    echo $(ls -a | wc -l)  # how many files are in $PWD
  #+end_src

  #+RESULTS:
  : 34

- Find all ~zip~ executables in ~/usr/bin~ and show the =file=
  characteristics of the top 10 results:
  #+begin_src bash
    file $(ls -d /usr/bin/* | grep zip | head)
  #+end_src  

  #+RESULTS:
  #+begin_example
  /usr/bin/bunzip2:           ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=04942293e732cd520714440dfeee0087129ea3ac, for GNU/Linux 3.2.0, stripped
  /usr/bin/bzip2:             ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=04942293e732cd520714440dfeee0087129ea3ac, for GNU/Linux 3.2.0, stripped
  /usr/bin/bzip2recover:      ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=2bafecb9d377975194d73514f413837ecbf22087, for GNU/Linux 3.2.0, stripped
  /usr/bin/funzip:            ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=f61e203872afd519a63e4d96296868315d06222b, for GNU/Linux 3.2.0, stripped
  /usr/bin/gpg-zip:           POSIX shell script, ASCII text executable
  /usr/bin/gunzip:            POSIX shell script, ASCII text executable
  /usr/bin/gzip:              ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=a7668faa2322e181773d5cba4bc5d8fd41e9b7c9, for GNU/Linux 3.2.0, stripped
  /usr/bin/lzip:              symbolic link to /etc/alternatives/lzip
  /usr/bin/lzip-compressor:   symbolic link to /etc/alternatives/lzip-compressor
  /usr/bin/lzip-decompressor: symbolic link to /etc/alternatives/lzip-decompressor
  #+end_example

- =bash= supports an older version of command substitution with
  backquotes instead of =$()=
  #+begin_src bash
    ls -l `which cp`
    echo `ls -l | wc -l`
  #+end_src

  #+RESULTS:
  : -rwxr-xr-x 1 root root 141832 Jan  8 08:56 /usr/bin/cp
  : 29
  
* Quoting

- In this example, whitespace is removed from the =echo= command
  argument list: the shell performs word splitting to do this.
  #+begin_src bash
    echo this is a     test
  #+end_src

  #+RESULTS:
  : this is a test

- In the next example, =$1= is replaced by an empty string because it is undefined.
  #+begin_src bash
    echo The total is $100.00
    echo $1
  #+end_src

  #+RESULTS:
  : The total is 00.00
  : 

- The shell provides a mechanism called /quoting/ to selectively
  suppress unwanted expansions.

* Double quotes

- Text inside double quotes is treated as ordinary characters: all
  special characters except =$=, =\= and =`= lose their special meaning.

- Word splitting, pathname expansion, tilde expansion, brace expansion
  are suppressed, but parameter expansion, arithmetic expansion, and
  command substitution are still carred out.

- With double quotes, we can handle filenames containing spaces (which
  Windows likes so much) - otherwise word splitting would mess us up.
  #+begin_example bash
    ls -l two words.txt
  #+end_example
  Yields the result:
  #+begin_example bash
    ls: cannot access 'two': No such file or directory
    ls: cannot access 'words.txt': No such file or directory
  #+end_example

- To fix it, use double quotes (works only if you have a file ~two words.txt~):
  #+begin_src bash
    ls -l "two words.txt"
  #+end_src

  #+RESULTS:
  : -rw-rw-r-- 1 marcus marcus 0 Mar 13 22:35 two words.txt

- You can even repair the damage:
  #+begin_src bash
    mv -v "two words.txt" two_words.txt
  #+end_src  

  #+RESULTS:
  : renamed 'two words.txt' -> 'two_words.txt'

- Parameter, arithmetic expansion and command substitution still work:
  #+begin_src bash
    echo "$USER"
    echo "$((2+2))"
    echo "$(date)"
  #+end_src

  #+RESULTS:
  : marcus
  : 4
  : Wed Mar 13 10:38:43 PM CDT 2024

* Word splitting

- Word splitting looks for spaces, tabs, and newlines, and treats them
  as word delimiters - unquoted, they are simply ignored.

- When we put a text with whitespace in quotes, word splitting is
  suppressed, and the whitespace becomes part of the argument:
  #+begin_src bash
    echo this is a     test
    echo "this is a     test"
  #+end_src

  #+RESULTS:
  : this is a test
  : this is a     test

- Command substitution suffers some side effects. Compare the two versions:
  #+begin_src bash
    echo $(cal)    # command substitution with word splitting
    echo "$(cal)"  # command substitution without word splitting
  #+end_src

  #+RESULTS:
  : March 2024 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
  :      March 2024       
  : Su Mo Tu We Th Fr Sa  
  :                 1  2  
  :  3  4  5  6  7  8  9  
  : 10 11 12 13 14 15 16  
  : 17 18 19 20 21 22 23  
  : 24 25 26 27 28 29 30  
  : 31                    

* Single quotes

- To suppress /all/ expansions, use single quotes

- Compare unquoted and quoted commands:
    
  #+begin_src bash
    echo text      # print argument
    echo ~/*.txt   # pathname expansion
    echo a{1..4}b  # brace expansion
    echo $(echo hello) # command substitution
    echo $((2+2))  # arithmetic expansion
    echo $USER     # parameter expansion
  #+end_src

  #+RESULTS:
  : text
  : /home/marcus/*.txt
  : a1b a2b a3b a4b
  : hello
  : 4
  : marcus

- Unquoted:
#+begin_src bash
  echo text ~/*.txt a{1..4}b $(echo hello) $((2+2)) $USER
#+end_src

#+RESULTS:
: text /home/marcus/*.txt a1b a2b a3b a4b hello 4 marcus

- Double quotes:
  #+begin_src bash
    echo "text ~/*.txt a{1..4}b $(echo hello) $((2+2)) $USER"
  #+end_src

  #+RESULTS:
  : text ~/*.txt a{1..4}b hello 4 marcus

- Single quotes:
  #+begin_src bash
    echo 'text ~/*.txt a{1..4}b $(echo hello) $((2+2)) $USER'
  #+end_src  

  #+RESULTS:
  : text ~/*.txt a{1..4}b $(echo hello) $((2+2)) $USER
  
* Escaping characters

- To quote a single character, precede it with a backslash =\= a
  so-called /escape character/ (it escapes the normal encoding).

- This is often done in quotes to prevent an expansion:
  #+begin_src bash
    echo "The balance for user $USER is \$100.00"
  #+end_src

  #+RESULTS:
  : The balance for user marcus is $100.00

- You can also escape the special meaning of characters in filenames:
  #+begin_src bash
    touch "bad&filename"; rm good_filename
    ls *filename
    mv -v bad\&filename good_filename
    ls *filename
  #+end_src  

  #+RESULTS:
  : bad&filename
  : renamed 'bad&filename' -> 'good_filename'
  : good_filename

- To escape a backslash itself, escape it with a backslash. With
  single quotes however, it loses its meaning:
  #+begin_src bash
    echo "The home of root is not \\ but /"
    echo 'The home of root is not \\ but /'
  #+end_src

  #+RESULTS:
  : The home of root is not \ but /
  : The home of root is not \\ but /

- The backslash is also part of the notation to represent /control
  codes/ to transmit commands to Teletype (=tty=) devices:

  | Escape sequence | Meaning         |
  |-----------------+-----------------|
  | \a              | Bell (beep)     |
  | \b              | Backspace       |
  | \n              | Newline         |
  | \r              | Carriage return |
  | \t              | Tab             |

- This use of \ comes from the C programming language and has been
  adopted by many others.

- To interpret these codes, add the =-e= flag to =echo= or place them
  inside =$''=. 
  #+begin_src bash
    sleep 10; echo -e "Time's up\a"  # countdown using sleep(1)
    sleep 10; echo -e "Time's up again" $'\a'
  #+end_src

  #+RESULTS:
  : Time's up
  : Time's up again 

  
* SUMMARY

| Command             | Explanation                                                                      |
|---------------------+----------------------------------------------------------------------------------|
| ~echo *~              | Lists all files in the current directory by expanding *                          |
| ~echo .*~             | Lists hidden files, including . and ..                                           |
| ~echo .[!.]*~         | Lists hidden files excluding . and ..                                            |
| ~echo ~~              | Prints the current user's home directory                                         |
| ~echo $((2+2))~       | Performs arithmetic expansion to print the result of 2+2                         |
| ~echo $(ls)~          | Uses command substitution to list directory contents in a single line            |
| ~echo "text"~         | Prints the text as is, treating everything inside quotes as a single string      |
| ~echo 'text'~         | Similar to double quotes, but prevents all expansions                            |
| ~echo \$variable~     | Escapes $ to prevent variable expansion and print $variable literally            |
| ~echo {2007..2009}~   | Uses brace expansion to print a sequence from 2007 to 2009                       |
| ~echo {A..C}~         | Uses brace expansion to print letters A through C                                |
| ~echo $USER~          | Prints the current user's username by expanding the USER environment variable    |
| ~echo $(echo hello)~  | Nested command substitution to print "hello"                                     |
| ~echo -e "text\nnew"~ | Uses -e option to enable interpretation of backslash escapes like \n for newline |
