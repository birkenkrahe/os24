#+TITLE:Permissions
#+AUTHOR:Marcus Birkenkrahe
#+SUBTITLE:permissions practice for CSC420 Operating Systems Spring 2024 Lyon College
#+STARTUP:overview hideblocks indent
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args:bash :results output :exports both :noweb yes
#+PROPERTY: header-args:python :python python3 :session *Python* :results output :exports both :comments both :tangle yes :noweb yes
* README

- To code along, download [[http://tinyurl.com/permissions-org][tinyurl.com/permissions-org]] and save the
  file as ~permissions.org~.

- This section is based on chapter 9 of Shotts, The Linux Command Line
  (2e), NoStarch Press (2019).

- Code tested with Linux Mint 21.3 Virginia and the Cinnamon 6.0.4
  Desktop running on a 2018 Dell Vostro 3470 (six i7-8700 cores).

* What is it?

- OS in the UNIX tradition are multi-tasking and multi-user systems.

- If the computer is attached to a network, remote users can log in
  via ~ssh~ (secure shell) and operate the computer, including GUIs.

- Multiuser capability of Linux is a deeply embedded OS feature
  because the first computers were not "personal".

- To make multiuser practical, users (and their data) had to be
  protected from one another.

- Related topics and commands:

  | COMMAND | MEANING                           |
  |---------+-----------------------------------|
  | =id=      | Display user identity             |
  | =chmod=   | Change a file's mode              |
  | =umask=   | Set the default file permissions  |
  | =su=      | Run a shell as another user       |
  | =sudo=    | Execute a command as another user |
  | =chgrp=   | Change a file's group ownership   |
  | =passwd=  | Change a user's password          |

* Example: a bad experience

- Check the file type of ~/etc/shadow~ using the =file= command:
  #+name: permission0
  #+begin_src bash :results output
    file /etc/shadow
  #+end_src

  #+RESULTS: permission0
  : /etc/shadow: regular file, no read permission

- Try to page the file using the ~less~ command. Anticipating an
  error (you have no read permission), redirect =stderr= to =stdout=:
  #+name: permission1
  #+begin_src bash :results output
    less /etc/shadow 2>&1
  #+end_src

  #+RESULTS: permission1
  : /etc/shadow: Permission denied

- As regular user, you don't have permission to look at this
  file. Check if you can at least see who does have permission.

  #+name: permission2
  #+begin_src bash :results output
    ls -l /etc/shadow 2>&1
  #+end_src

  #+RESULTS: permission2
  : -rw-r----- 1 root shadow 1575 Feb  9 16:21 /etc/shadow

- You've learnt that the owner (~root~) has read and write access, and
  members of the ~shadow~ group have read access. Anyone else has none.

- How would you find out more about =shadow= (without the web)?
  #+begin_src bash
    whatis shadow
    man shadow
  #+end_src

  #+RESULTS:
  #+begin_example
  shadow (5)           - shadowed password file
  SHADOW(5)                File Formats and Conversions                SHADOW(5)

  NAME
         shadow - shadowed password file

  DESCRIPTION
         shadow is a file which contains the password information for the
         system's accounts and optional aging information.

         This file must not be readable by regular users if password security is
         to be maintained.

         Each line of this file contains 9 fields, separated by colons (“:”), in
         the following order:

         login name
             It must be a valid account name, which exist on the system.

         encrypted password
             This field may be empty, in which case no passwords are required to
             authenticate as the specified login name. However, some
             applications which read the /etc/shadow file may decide not to
             permit any access at all if the password field is empty.

             A password field which starts with an exclamation mark means that
             the password is locked. The remaining characters on the line
             represent the password field before the password was locked.

             Refer to crypt(3) for details on how this string is interpreted.

             If the password field contains some string that is not a valid
             result of crypt(3), for instance ! or *, the user will not be able
             to use a unix password to log in (but the user may log in the
             system by other means).

         date of last password change
             The date of the last password change, expressed as the number of
             days since Jan 1, 1970.

             The value 0 has a special meaning, which is that the user should
             change her password the next time she will log in the system.

             An empty field means that password aging features are disabled.

         minimum password age
             The minimum password age is the number of days the user will have
             to wait before she will be allowed to change her password again.

             An empty field and value 0 mean that there are no minimum password
             age.

         maximum password age
             The maximum password age is the number of days after which the user
             will have to change her password.

             After this number of days is elapsed, the password may still be
             valid. The user should be asked to change her password the next
             time she will log in.

             An empty field means that there are no maximum password age, no
             password warning period, and no password inactivity period (see
             below).

             If the maximum password age is lower than the minimum password age,
             the user cannot change her password.

         password warning period
             The number of days before a password is going to expire (see the
             maximum password age above) during which the user should be warned.

             An empty field and value 0 mean that there are no password warning
             period.

         password inactivity period
             The number of days after a password has expired (see the maximum
             password age above) during which the password should still be
             accepted (and the user should update her password during the next
             login).

             After expiration of the password and this expiration period is
             elapsed, no login is possible using the current user's password.
             The user should contact her administrator.

             An empty field means that there are no enforcement of an inactivity
             period.

         account expiration date
             The date of expiration of the account, expressed as the number of
             days since Jan 1, 1970.

             Note that an account expiration differs from a password expiration.
             In case of an account expiration, the user shall not be allowed to
             login. In case of a password expiration, the user is not allowed to
             login using her password.

             An empty field means that the account will never expire.

             The value 0 should not be used as it is interpreted as either an
             account with no expiration, or as an expiration on Jan 1, 1970.

         reserved field
             This field is reserved for future use.

  FILES
         /etc/passwd
             User account information.

         /etc/shadow
             Secure user account information.

         /etc/shadow-
             Backup file for /etc/shadow.

             Note that this file is used by the tools of the shadow toolsuite,
             but not by all user and password management tools.

  SEE ALSO
         chage(1), login(1), passwd(1), passwd(5), pwck(8), pwconv(8),
         pwunconv(8), su(1), sulogin(8).

  shadow-utils 4.8.1                02/06/2024                         SHADOW(5)
  #+end_example

* The Unix security model

- In the UNIX security model, a user may /own/ files and directories.

- With ownership comes access control (and great responsibility).

- The user can belong to a /group/ of one or more users who are given
  access to files and directories by their owners.

- A user may also grant access rights to everyody (aka the /world/).

- Find out who you are in this model with the command ~id~.

  #+name: id
  #+begin_src bash :results output
    #id
    id | tr ',' '\n'  # `tr` translates characters
  #+end_src

  #+RESULTS: id
  : uid=1000(marcus) gid=1000(marcus) groups=1000(marcus)
  : 4(adm)
  : 24(cdrom)
  : 27(sudo)
  : 30(dip)
  : 46(plugdev)
  : 115(lpadmin)
  : 136(sambashare)

- When users are created, they are assigned a /user ID/ (/uid/),
  which is mapped to a user name.

- The user is also assigned a /group id/ (/gid/) and can be part of
  other groups.

- In the example [[id]], ~marcus~ is the first user with ~uid=1000~. This user
  is in the group with ~gid=1000~, and he is also member of a few other
  groups:
  1. As member of ~adm~ (~gid=4~) he can access system logs.
  2. As member of ~cdrom~ (~gid=24~) he can access CD/DVD ROM drives.
  3. As member of ~sudo~ (~gid=27~) he can become superuser.
  4. As member of ~dip~ (~gid=30~) he can open dial-up modem connections.
  5. As member of ~plugdev~ (~gid=46~) he can manage removable storage.
  6. As member of ~lpadmin~ (~gid=115~) he can manager printers.
  7. As member of ~sambashare~ (~gid=136~) he can share files over network[fn:1].

- The specific output is different for different Linux
  distros. E.g. Fedora Linux starts numbering uid at 500,
  Debian/Ubuntu at 1000.

- This information is stored in text files, of course: user accounts
  in ~/etc/passwd~, groups in ~/etc/group~.

- Take a look at the last 10 lines of ~/etc/passwd~ and ~/etc/group~:
  #+begin_src bash
    less /etc/passwd | tail
  #+end_src

  #+RESULTS:
  #+begin_example
  _flatpak:x:121:131:Flatpak system-wide installation helper,,,:/nonexistent:/usr/sbin/nologin
  avahi:x:122:132:Avahi mDNS daemon,,,:/run/avahi-daemon:/usr/sbin/nologin
  saned:x:123:133::/var/lib/saned:/usr/sbin/nologin
  colord:x:124:134:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin
  fwupd-refresh:x:125:135:fwupd-refresh user,,,:/run/systemd:/usr/sbin/nologin
  hplip:x:126:7:HPLIP system user,,,:/run/hplip:/bin/false
  marcus:x:1000:1000:Marcus Birkenkrahe,,,:/home/marcus:/bin/bash
  sssd:x:127:137:SSSD system user,,,:/var/lib/sss:/usr/sbin/nologin
  nvidia-persistenced:x:128:138:NVIDIA Persistence Daemon,,,:/nonexistent:/usr/sbin/nologin
  postfix:x:129:139::/var/spool/postfix:/usr/sbin/nologin
  #+end_example
  
  #+begin_src bash
    less /etc/group | tail
  #+end_src

  #+RESULTS:
  #+begin_example
  avahi:x:132:
  saned:x:133:
  colord:x:134:
  fwupd-refresh:x:135:
  marcus:x:1000:
  sambashare:x:136:marcus
  sssd:x:137:
  nvidia-persistenced:x:138:
  postfix:x:139:
  postdrop:x:140:
  #+end_example

- How many user and group accounts are there? Format the printout so
  that it looks like this:
  #+begin_example
   '/etc/passwd' has .. accounts
   '/etc/group'  has .. accounts   
  #+end_example

  #+begin_src bash
    echo "'/etc/passwd' has" $(cat /etc/passwd | wc -l) "accounts"
    echo "'/etc/group'  has " $(cat /etc/group | wc -l) "groups"    
  #+end_src

  #+RESULTS:
  : '/etc/passwd' has 49 accounts
  : '/etc/group'  has  80 groups

- ~/etc/shadow~ holds information about the user's password.

- What is the uid of the root user? Use ~grep~ to get the information
  about ~root~ from the file with the ~uid~ information

  This one returns too many entries:
  #+begin_src bash
    cat /etc/passwd | grep root
  #+end_src

  #+RESULTS:
  : root:x:0:0:root:/root:/bin/bash
  : nm-openvpn:x:117:126:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin

  Need those lines where ~root~ is the first word:
  #+name: root
  #+begin_src bash
    cat /etc/passwd | grep ^root
  #+end_src

  #+RESULTS: root
  : root:x:0:0:root:/root:/bin/bash

- Can you think about a way to directly get the uid for root?

  #+name: root_id
  #+begin_example bash
    sudo id  # you have to run this in a terminal e.g. M-x shell
  #+end_example

- You should get this output: ~uid=0(root) gid=0(root) groups=0(root)~
  because ~root~ is the first account created.

* Reading, Writing, and Executing

- Access rights to files and directories are defined in terms of
  *read* access, *write* access, and *execution* access.

- The long listing command ~ls -l~ shows how this is implemented.

- Create an empty file ~foo.txt~ using file *redirection*, and then print
  a long listing of the file.

  #+name: ll
  #+begin_src bash :results output
    > foo.txt
    ls -l foo.txt
  #+end_src

  #+RESULTS: ll
  : -rw-rw-r-- 1 marcus marcus 0 Mar 27 23:20 foo.txt

- You've seen this before: now let's analyze the permissions in detail.

* File attributes

- The first 10 characters of the listing are /file attributes/. Table
  [[tab:fa]] gives an overview.

  #+name: tab:fa
  | ATTRIBUTE | FILE TYPE              |
  |-----------+------------------------|
  | ~-~         | regular file           |
  | ~d~         | directory              |
  | ~l~         | symbolic link          |
  | ~c~         | character special file |
  | ~b~         | block special file     |

- For symbolic links, the remaining attributes are always dummy
  values. What do you think why that is?
  #+begin_quote
  Because a soft/symbolic link is not a file but only a pointer to a
  file with the real (non-dummy) permissions.
  #+end_quote

- Create a symbolic link ~~/shadow~ from ~/etc/shadow~:
  1) long-list the symbolic link to see the permissions
  2) execute =less= on the symbolic link
  
  #+begin_src bash
    rm -rf ~/shadow
    ln -s /etc/shadow ~/shadow
    ls -l ~/shadow
    less ~/shadow 
  #+end_src

  #+RESULTS:
  : lrwxrwxrwx 1 marcus marcus 11 Mar 27 23:25 /home/marcus/shadow -> /etc/shadow
  : /home/marcus/shadow: Permission denied

- Which "character special file" did you already encounter?  These
  files handle data as a stream of bytes.

  #+begin_quote
  Answers:
  1) ~/dev/null~ or the 'bit bucket'
  2) the terminal ~tty~ used for shell input and output in ~/dev~
  3) block special file, e.g. hard drive in ~/dev~
  #+end_quote

  #+begin_src bash
    ls -la /dev/null  # null device
    ls -la /dev/tty   # keyboard input output
    ls -la /dev/sda   # first disk device
  #+end_src

  #+RESULTS:
  : crw-rw-rw- 1 root root 1, 3 Mar 24 18:06 /dev/null
  : crw-rw-rw- 1 root tty 5, 0 Mar 27 23:14 /dev/tty
  : brw-rw---- 1 root disk 8, 0 Mar 24 18:06 /dev/sda


- A block special file handles data in blocks, e.g. a hard drive.

* File modes

- The remaining nine characters are the /file mode/ for the owner, the
  group, and the world with the permission settings: r=read, w=write,
  x=execute.

- Table [[tab:mode]] shows the effect that the mode has on files and
  directories. "Executing" a directory to Unix means "entering" it.

  #+name: tab:mode
  | ATTRIBUTE | FILES          | DIRECTORIES                                        |
  |-----------+----------------+----------------------------------------------------|
  | r         | can be opened  | can be listed if x is set (~dr-xr-xr-x~)             |
  | w         | can be written | files can be created, deleted, renamed if x is set |
  | x         | can be run     | allows a directory to be entered, e.g. with ~cd~     |

- Scripts(e.g. bash scripts) must also be set readable to be executed.

- Table [[tab:mode_ex]] shows some examples of file attribute
  settings.

  #+name: tab:mode_ex
  | ATTRIBUTE  | MEANING                                                                           |
  |------------+-----------------------------------------------------------------------------------|
  | -rwx------ | File, readable, writable, executable by owner only. Nobody else can access.       |
  | -rw------- | File, readable, writable by owner only. Nobody else can access.                   |
  | -rw-r--r-- | File, readable, writable by owner. Owner's group members & world may read         |
  | -rwxr-xr-x | File, readable, writable, executable by owner, can be read and executed by others |
  | -rw-rw---- | File, readable, writable by owner and members of file's owners group only         |
  | lrwxrwxrwx | Symbolic link with dummy permissions. Real permissions kept with file pointed to  |
  | drwxrwx--- | Directory. Owner & members of owner group may enter, create, rename, remove files |
  | drwxr-x--- | Directory. Owner may enter, create, rename, delete files here.                    |
  |            | Group members may enter but cannot write (add or change files).                   |

- Check ~/home~ where your ~$HOME~ is. What are the permissions, and what
  is everybody (the world) allowed to do or see?
  #+begin_src bash
    ls -l /home
  #+end_src

  #+RESULTS:
  : total 4
  : drwxr-x--- 30 marcus marcus 4096 Mar 27 23:33 marcus
  
  #+begin_quote
  Answer: you and your group can enter and read, only you can write to ~$HOME~
  #+end_quote

- Can you (as ~$USER~) create a file in ~/home~?

  #+begin_src bash
    ls -la /home
    id
  #+end_src

  #+RESULTS:
  : total 12
  : drwxr-xr-x  3 root   root   4096 Mar 16 11:50 .
  : drwxr-xr-x 20 root   root   4096 Mar 16 13:00 ..
  : drwxr-x--- 30 marcus marcus 4096 Mar 27 23:33 marcus
  : uid=1000(marcus) gid=1000(marcus) groups=1000(marcus),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),115(lpadmin),136(sambashare)

  #+begin_quote
  Answer: no! in ~/home~, only ~root~ and ~root~'s group have writing
  rights, and you are not in ~root~'s group.
  #+end_quote

* Changing file modes (=chmod=)

- Only file owners and superuser can change the mode of a file or
  directory using the command ~chmod~.

- Mode changes can be specified using octal numbers or symbols. Which
  you use is a matter of taste and upbringing.

* Changing file modes with octal numbers

- Octal people were born with 8 fingers. Different base systems,
  like octal (base 8), binary (base 2) or hexadecimal (base 16) can
  be used to abbreviate patterns that adhere to the base.

- Each digit in an octal number represents three (8 = 2^3) binary
  digits (useful to specify anything that comes in groups of
  three). Counting in octal is done with the numbers 0 through 7.

- Pixels e.g. are composed of 3 color components: 8 bits of red,
  green, blue each. A medium blue in binary would be a 24-digit
  number, but it can be condensed to a 6-digit hexadecimal, 436FCD.

- Table [[tab:octal]] shows the file modes in binary and in octal
  notation.

  #+name: tab:octal
  | OCTAL | BINARY | FILE MODE |
  |-------+--------+-----------|
  |     0 |    000 | ---       |
  |     1 |    001 | --x       |
  |     2 |    010 | -w-       |
  |     3 |    011 | -wx       |
  |     4 |    100 | r--       |
  |     5 |    101 | r-x       |
  |     6 |    110 | rw-       |
  |     7 |    111 | rwx       |

- Most languages have conversion functions for different bases,
  e.g. =oct= or =format= in Python to convert to octal:
  #+begin_example python 
    format(8,'o')  # decimal 8 to octal (10)
    format(8,'b')  # decimal 8 to binary (1000)
    oct(10)  # octal to decimal
  #+end_example

- By setting 3 octal digits, we can set the file mode for the owner,
  group owner, and world.

- Example: run the block [[chmod]]. An empty file is created and
  long-listed.

  #+name: chmod
  #+begin_src bash :results output
    rm -rf foo.txt  # we may already have a file like this
    > foo.txt
    ls -l foo.txt
  #+end_src

  #+RESULTS: chmod
  : -rw-rw-r-- 1 marcus marcus 0 Mar 28 07:39 foo.txt

- In the block [[chmod1]] below, change the permissions (file mode) to 600
  with the command ~chmod 600 [filename]~ and list the file.

  Check with the table that this is what was supposed to happen:
  read and write permissions for the owner, and no access rights for
  anyone else.

  #+name: chmod1
  #+begin_src bash :results output
    chmod 600 foo.txt # owner: rw- or 110, all others: --- or 000
    ls -l foo.txt
  #+end_src

  #+RESULTS: chmod1
  : -rw------- 1 marcus marcus 0 Mar 28 07:39 foo.txt

- Now change the mode of foo.txt to be readable by owner, group, and
  world, with no other permissions for any of these.

  #+name: chmod2
  #+begin_src bash :results output
    chmod 444 foo.txt
    ls -l foo.txt
  #+end_src

  #+RESULTS: chmod2
  : -r--r--r-- 1 marcus marcus 0 Mar 28 07:39 foo.txt

- Change the permissions for ~foo.txt~ back to default (~rw-rw-r--~):
  #+begin_src bash
    chmod 664 foo.txt
    ls -l foo.txt
  #+end_src

  #+RESULTS:
  : -rw-rw-r-- 1 marcus marcus 0 Mar 28 07:39 foo.txt

- What does ~chmod 775~ do? Why is this a common setting?
  #+begin_src bash
    chmod 775 foo.txt
    ls -l foo.txt
  #+end_src

  #+RESULTS:
  : -rwxrwxr-x 1 marcus marcus 0 Mar 28 07:39 foo.txt

  #+begin_quote
  Answer: this is the default setting for your directories (check)
  #+end_quote

  #+begin_src bash
    ls -ld */  # long-list directories only
  #+end_src

  #+RESULTS:
  : drwxrwxr-x  2 marcus marcus 4096 Mar 25 23:48 assignments/
  : drwxrwxr-x  2 marcus marcus 4096 Mar 27 23:19 codealong/
  : drwxrwxr-x 38 marcus marcus 4096 Mar 26 07:17 Photos/
  
* Changing file modes with symbols

- Symbolic notation is divided into three parts:
  - Who the change will affect
  - Which operation will be performed
  - What permission will be set

- To specify who is affected, a combination of characters is used,
  as shown in table [[tab:symmod]].

  #+name: tab:symmod
  | WHO | MEANING                        |
  |-----+--------------------------------|
  | u   | user = file or directory owner |
  | g   | group owner                    |
  | o   | others = world                 |
  | a   | all = combination of u,g,o     |

- If no character is specified, "all" (a) is assumed. Three
  operations are allowed, see table [[tab:opmod]]:

  #+name: tab:opmod
  | OPERATION | MEANING                                                    |
  |-----------+------------------------------------------------------------|
  | +         | permission to be added                                     |
  | -         | permission to be removed                                   |
  | =         | specified permissions to be applied and all others removed |

- Table [[tab:modex]] shows some examples. Multiple specifications may
  be separated by commas.

  #+name: tab:modex
  | NOTATION   | MEANING                                                               |
  |------------+-----------------------------------------------------------------------|
  | u+x        | add execute permission for owner                                      |
  | u-x        | remove execute permission for owner                                   |
  | +x         | add execute permission for owner, group, world                        |
  | a+x        | add execute permission for owner, group, world                        |
  | o-rw       | Remove read, write permissions from anyone except owner, group        |
  | go=rw      | Set group owner and anyone else to have read, write permissions.      |
  |            | Remove existing group owner/world execute permissions                 |
  | u+x, go=rx | Add execute permissions for owner, set read, execute for group/others |

- Example: in the block [[chmod3]], create an empty file ~bar.txt~ and
  long-list it:

  #+name: chmod3
  #+begin_src bash :results output
    rm -rf bar.txt
    > bar.txt
    ls -l bar.txt
  #+end_src

  #+RESULTS: chmod3
  : -rw-rw-r-- 1 marcus marcus 0 Mar 28 08:12 bar.txt

- In the block [[chmod4]] below, set the permissions for the owner, the
  group and others to read and write only, for ~bar.txt~. Use the
  command ~chmod [operation] [filename]~, then list the file.

  #+name: chmod4
  #+begin_src bash :results output
    chmod a=rw bar.txt
    ls -l bar.txt
  #+end_src

  #+RESULTS: chmod4
  : -rw-rw-rw- 1 marcus marcus 0 Mar 28 08:12 bar.txt

- Change the mode of bar.txt to be readable by owner and group only,
  with no other permissions for any of these.

  #+name: chmod5
  #+begin_src bash :results output
    chmod ug=r,o-rw bar.txt
    ls -l bar.txt
  #+end_src

  #+RESULTS: chmod5
  : -r--r----- 1 marcus marcus 0 Mar 28 08:12 bar.txt

* TODO Setting default permissions (=umask=)
* TODO Special permissions (=setuid=, =setgit=, sticky bit)
* TODO Changing identities (=su=, =sudo=)
* TODO Change file owner and group (=chown=)
* TODO Setting up a shared directory
* TODO Changing your password

* IN PROGRESS Summary

- Unix multiuser capability is fundamental, allowing user data
  protection from others.
- Essential commands related to user and group management include =id=,
  =chmod=, =umask=, =su=, =sudo=, =chgrp=, =passwd=.
- The Unix security model encompasses file ownership, group
  memberships, and access rights, delineating control over resources.
- User IDs (=uid=) and group IDs (=gid=) start at specific numbers varying
  by distribution, impacting system resource access and management.
- Access rights are categorized into read, write, and execute, with
  file permissions displayed using =ls -l=.


* Footnotes

[fn:1]Samba is a free software re-implementation of a networking
protocol that enables interoperability (= data exchange) between
Unix-like and Windows-like systems - e.g. share files, printers etc.
